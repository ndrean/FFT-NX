<!-- livebook:{"persist_outputs":true} -->

# Convolution with Nx

```elixir
Mix.install(
  [
    {:nx, "~> 0.9.2"},
    {:scidata, "~> 0.1.11"},
    {:exla, "~> 0.9.2"},
    {:kino, "~> 0.14.2"},
    {:stb_image, "~> 0.6.9"},
    {:axon, "~> 0.7.0"},
    {:kino_vega_lite, "~> 0.1.11"},
    {:nx_signal, "~> 0.2.0"},
    {:emlx, github: "elixir-nx/emlx", ovveride: true}
  ],
  #config: [nx: [default_backend: EXLA.Backend]]
  config: [nx: [default_backend: {EMLX.Backend, device: :gpu}]]
)

Nx.Defn.default_options(compiler: EMLX)
```

## What is a convolution?

From a pragmatic perspective, multiplying two polynomials is effectively performing a convolution.

Formally, the __convolution product__ is a mathematical operation that can be understood as a sum of "sliding products" between two tensors.

This operation is widely used in signal processing and has applications in various fields such as image processing, audio filtering, and machine learning.

#### How do you compute it?

There is a formula that sums over the number of samples or points of the signal we consider.

$$(s\circledast f)[n] = \sum_{i=-N}^{N} s[i-n]f[i]$$

#### Link with the Discrete Fourier Ttansform

Consider a signal $s(t)$ that we want to transform using a filtering signal $f(t)$.

The convolution product $(s \star f)(t)$ has a remarkable property when viewed in the frequency domain.

Denote as $\hat{s}(\omega)$ and $\hat{f}(\omega)$ the Discrete Fourier Transform of $s$ and $f$ respectively (the DFT is implemented as a Fast Fourier Transform). We have a remarkable relationship: a multiplication (term by term) in the frequency domain is a DFT of a (circular) convolution.

$$\hat{s}(\omega) \cdot \hat{f}(\omega) = \widehat{s\circledast f}(\omega)$$

The key insight is that convolution in the time or spatial domain becomes a multiplication in the frequency domain, providing methods for signal transformation and filtering.

For instance, to remove specific frequencies, one can construct a filter $\hat{f}$ that is:

* 1 for all frequencies except the target region, say $\omega<\omega_c$
* 0 within the frequencies to be removed, so when $\omega>\omega_c$

By taking the inverse Fourier transform of this filter,   $\mathcal{F}^{-1}(\hat{f})$, we can implement the desired frequency filtering. The inverse of such a "window" function is:

$$f(t)=\dfrac{sin(\omega_c t)}{\pi t}$$

Furthermore, you see that one way to compute a convolution is to pad correctly the tensors, take the FFTs, do a (term by term) multiplication and take the inverse Fourier transform of this product:

$$s\circledast f = \mathcal{F}^{-1}(\hat{s}\cdot \hat{f})$$

## How to use `Nx.conv`

The function `Nx.conv` as written is useful for `Axon` and neural networks as the coefficients are learnt by an iteration process.

However, if the kernel is given, then you will notice that the function as written is __not__ the convolution but the __correlation__. The good part is that result is same if and only if the kernel is symmetric.

To use it in particular for 1D vectors, you need to `Nx.reverse` the kernel. Furthermore, you need to respect the input shape, so you need to `Nx.reshape` the tensor.

You have the following parameters:

* padding
* shape
* stride
* permutation

The shape is expected to be: `{batch_size, channel, dim_1, ...}`

The stride parameter defines how the kernel slides along the axes. A stride of 1 means the kernel moves one step at a time, while larger strides result in skipping over positions.

The batch_size parameter is crucial when working with colored images, as it allows you to convolve each color channel separately while maintaining the output's color information.

In contrast, for a convolution layer in a neural network, you might average all color channels and work with a grayscale image instead. This reduces computational complexity while still capturing essential features.

#### Example with a vector

If `t = Nx.shape(t)= {n}`, you can simply use `t` as a input in a convolution by doing `Nx.reshape({1,1,n})`. This respects the pattern:

batch_size=1, channel=1, dim_1=n.

#### Example with an image

For example, you have a tensor that represents an RGBA image (coloured). Its shape is typically:

`{h,w,c} = {256,256,4}`.

You may want to set 4 for the batch_size, to batch per colour layer. We will use a permutation on the tensor. How?

* you add a new dimension: `Nx.new_axis(t, 0)`. The new shape of the tensor is `{1, 256,256,4}`.
* you set the `permutation_input` to permute the tensor with `[3,0,1,2]` because the second dimension must be the channel. You understand why you had to add a "fake" dimension to respect the pattern:

batch_size=4, channels=1, dim_1 = 256, dim_2=256

## Padding a tensor

You will notice that we "pad" the tensors. This means that we add "zeros" to the signal function in order to build an input that is zero outisde of the number of points ($N$ here). This is done below with `padding: :same` or in the polynomial product or in the image filtering.

Some examples on how to use the function `Nx.pad` with a 1D tensor to add numbers to a tensor.

```elixir
t = Nx.tensor([1,2,3])
one_zero_left = Nx.pad(t, 0, [{1,0,0}])
two_5_right = Nx.pad(t, 5, [{0,2,0}])

[t, one_zero_left, two_5_right] 
|> Enum.map(&Nx.to_list/1)
```

<!-- livebook:{"output":true} -->

```
[[1, 2, 3], [0, 1, 2, 3], [1, 2, 3, 5, 5]]
```

With a 2D-tensor, you need to add an extra dimension. For example, take:

```elixir
m = Nx.tensor([[1,2],[3,4]])
```

<!-- livebook:{"output":true} -->

```
#Nx.Tensor<
  s32[2][2]
  EMLX.Backend<gpu, 0.1937529058.1490157570.226889>
  [
    [1, 2],
    [3, 4]
  ]
>
```

We will successfully:

* add zero-padding on the first and last row
* add zero-padding on the first column and last column
* "suround" the tensor with zeroes

```elixir
{Nx.pad(m, 0, [{1,1,0}, {0,0,0}]), Nx.pad(m, 0, [{0,0,0}, {1,1,0}]), 
  Nx.pad(m, 0, [{1,1,0}, {1,1,0}])}
```

<!-- livebook:{"output":true} -->

```
{#Nx.Tensor<
   s32[4][2]
   EMLX.Backend<gpu, 0.1937529058.1490157570.226922>
   [
     [0, 0],
     [1, 2],
     [3, 4],
     [0, 0]
   ]
 >,
 #Nx.Tensor<
   s32[2][4]
   EMLX.Backend<gpu, 0.1937529058.1490157570.226925>
   [
     [0, 1, 2, 0],
     [0, 3, 4, 0]
   ]
 >,
 #Nx.Tensor<
   s32[4][4]
   EMLX.Backend<gpu, 0.1937529058.1490157570.226928>
   [
     [0, 0, 0, 0],
     [0, 1, 2, 0],
     [0, 3, 4, 0],
     [0, 0, 0, 0]
   ]
 >}
```

## Example of convolution and FFT

We use again our signal composed of two signals with frequency 5Hz (or period of 1/5s) and 20Hz (ie period of 1/20s).

$s=\sin(2 \pi 5t ) + \frac14\sin(2\pi 20 t)$

If we want to filter frequencies above $f_c=10$Hz,  our filter signal in the frequency domain can be:

$\hat{f}(\omega) = 1$ when $|\omega|<\omega_c = 2\pi f_c$

$\hat{f}(\omega) = 0$ when $|\omega|>\omega_c = 2\pi f_c$

Its "Fourier inverse" is:

$$\dfrac{\sin(2\pi f_c t)}{\pi t}$$

Let's verify the following:

* if we compute the FFT of our signal $s$,  multiply by our window function $\hat{f}$, and then take its IFFT, the resulting signal should have the perturbation at 20Hz removed,
* If we perform a "standard" convolution of $s$ with the corresponding time-domain representation of the filter $\mathcal{F}^{-1}(\hat{f})$, compute its FFT, and analyze the result, we should find that the transformed signal is free of significant perturbations at 20Hz. Specifically, the FFT of the convolved signal should not exhibit a notable amplitude at 20Hz.

<!-- livebook:{"break_markdown":true} -->

#### Direct convolution in the time (or spatial) domain

We firstly evaluate the "direct" convolution. We plot the convolution of the signal with the filter.

```elixir
defmodule C do
  import Nx.Defn
  import Nx.Constants, only: [pi: 0]

  defn bins(opts) do
    start = opts[:start]
    end_point = opts[:end_point]
    fs = opts[:fs]
    Nx.linspace(start, end_point, n: fs, endpoint: true, type: :f32)
  end
  
  defn sample(t) do
    f1 = 5; f2 = 20;
    Nx.sin(2 * pi() * f1 * t ) + 1/4 * Nx.sin(2 * pi() * f2 * t)
  end
    
  defn filter(t, opts) do
    fc = opts[:fc]
    Nx.sin(2*pi()*fc*t) / (pi()*t)
  end

  def conv(s,f) do
    s = Nx.reshape(s, {1,1,Nx.size(s)})
    f = Nx.reshape(f, {1,1,Nx.size(f)})
    Nx.conv(s, Nx.reverse(f), padding: :same)
  end

  defn base(t) do
    f1 = 5;
    Nx.sin(2 * pi() * f1 * t )
  end
end

fs = 200
# center the curve for the FFT of the conv
opts = [start: -0.5, end_point: 0.5, fs: fs ]

x = C.bins(opts) 
y_signal = C.sample(x) 
fc = 10
y_filter = C.filter(x, fc: fc)

y_conv_s_f = C.conv(y_signal, y_filter) |> Nx.flatten()

signal = %{x: Nx.to_list(x), y: Nx.to_list(y_signal)}
#filter = %{x: Nx.to_list(x), y: Nx.to_list(y_filter)}
conv_s_f = %{x: Nx.to_list(x) , y: Nx.to_list(y_conv_s_f)}

VegaLite.new(width: 700, height: 400)
|> VegaLite.layers([
  VegaLite.new()
  |> VegaLite.data_from_values(signal, only: ["x", "y"])
  |> VegaLite.mark(:line)
  |> VegaLite.encode_field(:x, "x", type: :quantitative ,title: "time samples (s)")
  |> VegaLite.encode_field(:y, "y", type: :quantitative, title: "signal amplitude"),
  VegaLite.new()
  |> VegaLite.data_from_values(conv_s_f, only: ["x", "y"])
  |> VegaLite.mark(:line)
  |> VegaLite.encode_field(:x, "x", type: :quantitative)
  |> VegaLite.encode_field(:y, "y", type: :quantitative, title: "convolution"),
])
|> VegaLite.resolve(:scale, y: :independent)
```

<!-- livebook:{"output":true} -->

```vega-lite
{"$schema":"https://vega.github.io/schema/vega-lite/v5.json","height":400,"layer":[{"data":{"values":[{"x":-0.5,"y":0.0},{"x":-0.49497488141059875,"y":-0.00962965190410614},{"x":-0.4899497628211975,"y":-0.0722702145576477},{"x":-0.4849246144294739,"y":-0.21907682716846466},{"x":-0.47989949584007263,"y":-0.44595611095428467},{"x":-0.4748743772506714,"y":-0.7138372659683228},{"x":-0.46984925866127014,"y":-0.9625411033630371},{"x":-0.4648241102695465,"y":-1.1329147815704346},{"x":-0.45979899168014526,"y":-1.1887260675430298},{"x":-0.454773873090744,"y":-1.1299153566360474},{"x":-0.4497487545013428,"y":-0.9920775890350342},{"x":-0.44472360610961914,"y":-0.8324124813079834},{"x":-0.4396984875202179,"y":-0.7075670957565308},{"x":-0.43467336893081665,"y":-0.6519074440002441},{"x":-0.4296482503414154,"y":-0.6646065711975098},{"x":-0.42462313175201416,"y":-0.7105206847190857},{"x":-0.4195979833602905,"y":-0.7344931364059448},{"x":-0.4145728647708893,"y":-0.6835602521896362},{"x":-0.40954774618148804,"y":-0.5284665822982788},{"x":-0.4045225977897644,"y":-0.27616140246391296},{"x":-0.39949747920036316,"y":0.031562406569719315},{"x":-0.3944723606109619,"y":0.33280718326568604},{"x":-0.38944724202156067,"y":0.5680375099182129},{"x":-0.3844221234321594,"y":0.701622724533081},{"x":-0.3793969750404358,"y":0.7342182397842407},{"x":-0.37437185645103455,"y":0.7012088894844055},{"x":-0.3693467378616333,"y":0.6578727960586548},{"x":-0.36432158946990967,"y":0.6570005416870117},{"x":-0.3592965006828308,"y":0.7276380658149719},{"x":-0.3542713522911072,"y":0.863172173500061},{"x":-0.34924623370170593,"y":1.0233643054962158},{"x":-0.3442211151123047,"y":1.149572491645813},{"x":-0.33919596672058105,"y":1.187292218208313},{"x":-0.3341708779335022,"y":1.107320785522461},{"x":-0.32914572954177856,"y":0.9173837900161743},{"x":-0.3241206109523773,"y":0.6597340106964111},{"x":-0.3190954923629761,"y":0.39562535285949707},{"x":-0.31407034397125244,"y":0.1826307773590088},{"x":-0.3090452253818512,"y":0.05354732275009155},{"x":-0.30402010679244995,"y":0.004968412220478058},{"x":-0.2989949584007263,"y":-7.862597703933716e-5},{"x":-0.29396986961364746,"y":-0.016485348343849182},{"x":-0.28894472122192383,"y":-0.09447944164276123},{"x":-0.2839196026325226,"y":-0.25884532928466797},{"x":-0.27889448404312134,"y":-0.49799883365631104},{"x":-0.2738693356513977,"y":-0.7671739459037781},{"x":-0.26884421706199646,"y":-1.0044925212860107},{"x":-0.2638190984725952,"y":-1.153804898262024},{"x":-0.25879397988319397,"y":-1.1854548454284668},{"x":-0.2537688612937927,"y":-1.1070243120193481},{"x":-0.2487437129020691,"y":-0.9599180221557617},{"x":-0.24371859431266785,"y":-0.8031195998191833},{"x":-0.2386934757232666,"y":-0.690381646156311},{"x":-0.23366835713386536,"y":-0.6496643424034119},{"x":-0.22864320874214172,"y":-0.6727371215820312},{"x":-0.22361809015274048,"y":-0.7189478874206543},{"x":-0.21859297156333923,"y":-0.7316920757293701},{"x":-0.213567852973938,"y":-0.6612088680267334},{"x":-0.20854270458221436,"y":-0.48488742113113403},{"x":-0.2035175859928131,"y":-0.21722866594791412},{"x":-0.19849246740341187,"y":0.09442003071308136},{"x":-0.19346734881401062,"y":0.3867341876029968},{"x":-0.188442200422287,"y":0.6034225225448608},{"x":-0.18341708183288574,"y":0.7155294418334961},{"x":-0.1783919632434845,"y":0.7312520146369934},{"x":-0.17336684465408325,"y":0.6914923191070557},{"x":-0.168341726064682,"y":0.6529172658920288},{"x":-0.16331657767295837,"y":0.6650745272636414},{"x":-0.15829145908355713,"y":0.7504196166992188},{"x":-0.15326634049415588,"y":0.8949815034866333},{"x":-0.14824122190475464,"y":1.0532786846160889},{"x":-0.143216073513031,"y":1.165605902671814},{"x":-0.13819095492362976,"y":1.1810264587402344},{"x":-0.13316583633422852,"y":1.0772103071212769},{"x":-0.12814071774482727,"y":0.8694507479667664},{"x":-0.12311556935310364,"y":0.6053817272186279},{"x":-0.11809045076370239,"y":0.3474195599555969},{"x":-0.11306533217430115,"y":0.14966140687465668},{"x":-0.1080402135848999,"y":0.03815723955631256},{"x":-0.10301506519317627,"y":0.0021084770560264587},{"x":-0.09798994660377502,"y":-6.273873150348663e-4},{"x":-0.09296482801437378,"y":-0.02589067816734314},{"x":-0.08793970942497253,"y":-0.12026651203632355},{"x":-0.08291459083557129,"y":-0.30171680450439453},{"x":-0.07788944244384766,"y":-0.5513032674789429},{"x":-0.07286432385444641,"y":-0.8192144632339478},{"x":-0.06783920526504517,"y":-1.0428324937820435},{"x":-0.06281408667564392,"y":-1.1698638200759888},{"x":-0.05778893828392029,"y":-1.177666187286377},{"x":-0.05276381969451904,"y":-1.0813257694244385},{"x":-0.0477387011051178,"y":-0.9273891448974609},{"x":-0.04271358251571655,"y":-0.7756766080856323},{"x":-0.03768843412399292,"y":-0.6761988997459412},{"x":-0.032663315534591675,"y":-0.650082528591156},{"x":-0.02763819694519043,"y":-0.6818469762802124},{"x":-0.022613078355789185,"y":-0.7260133028030396},{"x":-0.01758795976638794,"y":-0.7254704236984253},{"x":-0.012562811374664307,"y":-0.6344980001449585},{"x":-0.0075376927852630615,"y":-0.43754464387893677},{"x":-0.0025125741958618164,"y":-0.1564827710390091},{"x":0.0025125741958618164,"y":0.1564827710390091},{"x":0.007537662982940674,"y":0.43754321336746216},{"x":0.012562811374664307,"y":0.6344980001449585},{"x":0.01758795976638794,"y":0.7254704236984253},{"x":0.022613048553466797,"y":0.7260134220123291},{"x":0.02763819694519043,"y":0.6818469762802124},{"x":0.03266328573226929,"y":0.6500825881958008},{"x":0.03768843412399292,"y":0.6761988997459412},{"x":0.04271358251571655,"y":0.7756766080856323},{"x":0.04773867130279541,"y":0.9273881912231445},{"x":0.05276381969451904,"y":1.0813257694244385},{"x":0.057788968086242676,"y":1.177666425704956},{"x":0.06281405687332153,"y":1.1698641777038574},{"x":0.06783920526504517,"y":1.0428324937820435},{"x":0.07286429405212402,"y":0.8192160129547119},{"x":0.07788944244384766,"y":0.5513032674789429},{"x":0.08291459083557129,"y":0.30171680450439453},{"x":0.08793967962265015,"y":0.12026733160018921},{"x":0.09296482801437378,"y":0.02589067816734314},{"x":0.09798991680145264,"y":6.274133920669556e-4},{"x":0.10301506519317627,"y":-0.0021084770560264587},{"x":0.1080402135848999,"y":-0.03815723955631256},{"x":0.11306530237197876,"y":-0.14966045320034027},{"x":0.11809045076370239,"y":-0.3474195599555969},{"x":0.12311559915542603,"y":-0.6053832769393921},{"x":0.12814068794250488,"y":-0.869449257850647},{"x":0.13316583633422852,"y":-1.0772103071212769},{"x":0.13819092512130737,"y":-1.1810262203216553},{"x":0.143216073513031,"y":-1.165605902671814},{"x":0.14824122190475464,"y":-1.0532786846160889},{"x":0.1532663106918335,"y":-0.8949825167655945},{"x":0.15829145908355713,"y":-0.7504196166992188},{"x":0.163316547870636,"y":-0.6650746464729309},{"x":0.16834169626235962,"y":-0.6529171466827393},{"x":0.17336684465408325,"y":-0.6914923191070557},{"x":0.1783919334411621,"y":-0.7312518358230591},{"x":0.18341708183288574,"y":-0.7155294418334961},{"x":0.18844223022460938,"y":-0.6034215092658997},{"x":0.19346731901168823,"y":-0.386735737323761},{"x":0.19849246740341187,"y":-0.09442003071308136},{"x":0.20351755619049072,"y":0.21722683310508728},{"x":0.20854270458221436,"y":0.48488742113113403},{"x":0.213567852973938,"y":0.6612088680267334},{"x":0.21859294176101685,"y":0.7316919565200806},{"x":0.22361809015274048,"y":0.7189478874206543},{"x":0.22864317893981934,"y":0.6727374196052551},{"x":0.23366832733154297,"y":0.6496644020080566},{"x":0.2386934757232666,"y":0.690381646156311},{"x":0.24371856451034546,"y":0.8031187653541565},{"x":0.2487437129020691,"y":0.9599180221557617},{"x":0.2537688612937927,"y":1.1070243120193481},{"x":0.2587939500808716,"y":1.1854546070098877},{"x":0.2638190984725952,"y":1.153804898262024},{"x":0.2688441872596741,"y":1.0044935941696167},{"x":0.2738693356513977,"y":0.7671739459037781},{"x":0.27889448404312134,"y":0.49799883365631104},{"x":0.2839195728302002,"y":0.25884658098220825},{"x":0.28894472122192383,"y":0.09447944164276123},{"x":0.29396986961364746,"y":0.016485348343849182},{"x":0.2989949584007263,"y":7.862597703933716e-5},{"x":0.30402010679244995,"y":-0.004968412220478058},{"x":0.3090451955795288,"y":-0.05354680120944977},{"x":0.31407034397125244,"y":-0.1826307773590088},{"x":0.3190954923629761,"y":-0.39562535285949707},{"x":0.32412058115005493,"y":-0.6597324013710022},{"x":0.32914572954177856,"y":-0.9173837900161743},{"x":0.3341708183288574,"y":-1.1073191165924072},{"x":0.33919596672058105,"y":-1.187292218208313},{"x":0.3442211151123047,"y":-1.149572491645813},{"x":0.34924620389938354,"y":-1.0233652591705322},{"x":0.3542713522911072,"y":-0.863172173500061},{"x":0.3592965006828308,"y":-0.7276380658149719},{"x":0.36432158946990967,"y":-0.6570005416870117},{"x":0.3693467378616333,"y":-0.6578727960586548},{"x":0.37437182664871216,"y":-0.7012085914611816},{"x":0.3793969750404358,"y":-0.7342182397842407},{"x":0.3844221234321594,"y":-0.701622724533081},{"x":0.3894472122192383,"y":-0.5680387020111084},{"x":0.3944723606109619,"y":-0.33280718326568604},{"x":0.39949744939804077,"y":-0.03156431019306183},{"x":0.4045225977897644,"y":0.27616140246391296},{"x":0.40954774618148804,"y":0.5284665822982788},{"x":0.4145728349685669,"y":0.6835596561431885},{"x":0.4195979833602905,"y":0.7344931364059448},{"x":0.42462313175201416,"y":0.7105206847190857},{"x":0.429648220539093,"y":0.6646067500114441},{"x":0.43467336893081665,"y":0.6519074440002441},{"x":0.4396984577178955,"y":0.7075665593147278},{"x":0.44472360610961914,"y":0.8324124813079834},{"x":0.4497487545013428,"y":0.9920775890350342},{"x":0.45477384328842163,"y":1.1299147605895996},{"x":0.45979899168014526,"y":1.1887260675430298},{"x":0.4648240804672241,"y":1.1329154968261719},{"x":0.46984922885894775,"y":0.9625423550605774},{"x":0.4748743772506714,"y":0.7138372659683228},{"x":0.47989946603775024,"y":0.44595766067504883},{"x":0.4849246144294739,"y":0.21907682716846466},{"x":0.4899497628211975,"y":0.0722702145576477},{"x":0.49497485160827637,"y":0.009629815816879272},{"x":0.5,"y":0.0}]},"encoding":{"x":{"field":"x","title":"time samples (s)","type":"quantitative"},"y":{"field":"y","title":"signal amplitude","type":"quantitative"}},"mark":"line"},{"data":{"values":[{"x":-0.5,"y":-34.54206466674805},{"x":-0.49497488141059875,"y":-52.924583435058594},{"x":-0.4899497628211975,"y":-73.14665985107422},{"x":-0.4849246144294739,"y":-94.49732208251953},{"x":-0.47989949584007263,"y":-116.12006378173828},{"x":-0.4748743772506714,"y":-137.0571746826172},{"x":-0.46984925866127014,"y":-156.308349609375},{"x":-0.4648241102695465,"y":-172.89649963378906},{"x":-0.45979899168014526,"y":-185.93008422851562},{"x":-0.454773873090744,"y":-194.656005859375},{"x":-0.4497487545013428,"y":-198.49627685546875},{"x":-0.44472360610961914,"y":-197.06890869140625},{"x":-0.4396984875202179,"y":-190.19509887695312},{"x":-0.43467336893081665,"y":-177.8992919921875},{"x":-0.4296482503414154,"y":-160.40374755859375},{"x":-0.42462313175201416,"y":-138.1234130859375},{"x":-0.4195979833602905,"y":-111.65583801269531},{"x":-0.4145728647708893,"y":-81.76739501953125},{"x":-0.40954774618148804,"y":-49.36773681640625},{"x":-0.4045225977897644,"y":-15.47294807434082},{"x":-0.39949747920036316,"y":18.843809127807617},{"x":-0.3944723606109619,"y":52.508506774902344},{"x":-0.38944724202156067,"y":84.50225830078125},{"x":-0.3844221234321594,"y":113.90936279296875},{"x":-0.3793969750404358,"y":139.95054626464844},{"x":-0.37437185645103455,"y":161.99900817871094},{"x":-0.3693467378616333,"y":179.5809326171875},{"x":-0.36432158946990967,"y":192.36572265625},{"x":-0.3592965006828308,"y":200.15257263183594},{"x":-0.3542713522911072,"y":202.85987854003906},{"x":-0.34924623370170593,"y":200.51980590820312},{"x":-0.3442211151123047,"y":193.2767791748047},{"x":-0.33919596672058105,"y":181.38833618164062},{"x":-0.3341708779335022,"y":165.22076416015625},{"x":-0.32914572954177856,"y":145.23826599121094},{"x":-0.3241206109523773,"y":121.9829330444336},{"x":-0.3190954923629761,"y":96.04985046386719},{"x":-0.31407034397125244,"y":68.06095123291016},{"x":-0.3090452253818512,"y":38.6450309753418},{"x":-0.30402010679244995,"y":8.42695426940918},{"x":-0.2989949584007263,"y":-21.97280502319336},{"x":-0.29396986961364746,"y":-51.93122863769531},{"x":-0.28894472122192383,"y":-80.81478881835938},{"x":-0.2839196026325226,"y":-107.97653198242188},{"x":-0.27889448404312134,"y":-132.76405334472656},{"x":-0.2738693356513977,"y":-154.5387420654297},{"x":-0.26884421706199646,"y":-172.7051544189453},{"x":-0.2638190984725952,"y":-186.74252319335938},{"x":-0.25879397988319397,"y":-196.23419189453125},{"x":-0.2537688612937927,"y":-200.8872528076172},{"x":-0.2487437129020691,"y":-200.54129028320312},{"x":-0.24371859431266785,"y":-195.16700744628906},{"x":-0.2386934757232666,"y":-184.859619140625},{"x":-0.23366835713386536,"y":-169.83157348632812},{"x":-0.22864320874214172,"y":-150.40850830078125},{"x":-0.22361809015274048,"y":-127.02996826171875},{"x":-0.21859297156333923,"y":-100.25198364257812},{"x":-0.213567852973938,"y":-70.74545288085938},{"x":-0.20854270458221436,"y":-39.2867317199707},{"x":-0.2035175859928131,"y":-6.735349655151367},{"x":-0.19849246740341187,"y":25.999906539916992},{"x":-0.19346734881401062,"y":58.00326156616211},{"x":-0.188442200422287,"y":88.39542388916016},{"x":-0.18341708183288574,"y":116.37128448486328},{"x":-0.1783919632434845,"y":141.22589111328125},{"x":-0.17336684465408325,"y":162.36769104003906},{"x":-0.168341726064682,"y":179.31956481933594},{"x":-0.16331657767295837,"y":191.71466064453125},{"x":-0.15829145908355713,"y":199.29241943359375},{"x":-0.15326634049415588,"y":201.89784240722656},{"x":-0.14824122190475464,"y":199.48716735839844},{"x":-0.143216073513031,"y":192.13665771484375},{"x":-0.13819095492362976,"y":180.0507049560547},{"x":-0.13316583633422852,"y":163.5620574951172},{"x":-0.12814071774482727,"y":143.12217712402344},{"x":-0.12311556935310364,"y":119.28082275390625},{"x":-0.11809045076370239,"y":92.6592788696289},{"x":-0.11306533217430115,"y":63.92110061645508},{"x":-0.1080402135848999,"y":33.748619079589844},{"x":-0.10301506519317627,"y":2.8280773162841797},{"x":-0.09798994660377502,"y":-28.15542984008789},{"x":-0.09296482801437378,"y":-58.5166015625},{"x":-0.08793970942497253,"y":-87.56793212890625},{"x":-0.08291459083557129,"y":-114.62276458740234},{"x":-0.07788944244384766,"y":-139.0083465576172},{"x":-0.07286432385444641,"y":-160.08836364746094},{"x":-0.06783920526504517,"y":-177.29193115234375},{"x":-0.06281408667564392,"y":-190.1441650390625},{"x":-0.05778893828392029,"y":-198.28952026367188},{"x":-0.05276381969451904,"y":-201.5053253173828},{"x":-0.0477387011051178,"y":-199.7040557861328},{"x":-0.04271358251571655,"y":-192.92556762695312},{"x":-0.03768843412399292,"y":-181.32614135742188},{"x":-0.032663315534591675,"y":-165.16812133789062},{"x":-0.02763819694519043,"y":-144.81552124023438},{"x":-0.022613078355789185,"y":-120.73403930664062},{"x":-0.01758795976638794,"y":-93.49368286132812},{"x":-0.012562811374664307,"y":-63.76781463623047},{"x":-0.0075376927852630615,"y":-32.32343673706055},{"x":-0.0025125741958618164,"y":-5.817413330078125e-5},{"x":0.0025125741958618164,"y":32.32331466674805},{"x":0.007537662982940674,"y":63.767642974853516},{"x":0.012562811374664307,"y":93.4935073852539},{"x":0.01758795976638794,"y":120.73384094238281},{"x":0.022613048553466797,"y":144.81544494628906},{"x":0.02763819694519043,"y":165.16796875},{"x":0.03266328573226929,"y":181.3260040283203},{"x":0.03768843412399292,"y":192.92556762695312},{"x":0.04271358251571655,"y":199.7041015625},{"x":0.04773867130279541,"y":201.50540161132812},{"x":0.05276381969451904,"y":198.28958129882812},{"x":0.057788968086242676,"y":190.1442108154297},{"x":0.06281405687332153,"y":177.2920379638672},{"x":0.06783920526504517,"y":160.08839416503906},{"x":0.07286429405212402,"y":139.00848388671875},{"x":0.07788944244384766,"y":114.62287902832031},{"x":0.08291459083557129,"y":87.56800842285156},{"x":0.08793967962265015,"y":58.516719818115234},{"x":0.09296482801437378,"y":28.15553092956543},{"x":0.09798991680145264,"y":-2.827974319458008},{"x":0.10301506519317627,"y":-33.74852752685547},{"x":0.1080402135848999,"y":-63.92105484008789},{"x":0.11306530237197876,"y":-92.6592025756836},{"x":0.11809045076370239,"y":-119.28079223632812},{"x":0.12311559915542603,"y":-143.12210083007812},{"x":0.12814068794250488,"y":-163.56210327148438},{"x":0.13316583633422852,"y":-180.05067443847656},{"x":0.13819092512130737,"y":-192.13661193847656},{"x":0.143216073513031,"y":-199.48704528808594},{"x":0.14824122190475464,"y":-201.89785766601562},{"x":0.1532663106918335,"y":-199.29249572753906},{"x":0.15829145908355713,"y":-191.71466064453125},{"x":0.163316547870636,"y":-179.3195343017578},{"x":0.16834169626235962,"y":-162.36773681640625},{"x":0.17336684465408325,"y":-141.22604370117188},{"x":0.1783919334411621,"y":-116.37139892578125},{"x":0.18341708183288574,"y":-88.39551544189453},{"x":0.18844223022460938,"y":-58.003353118896484},{"x":0.19346731901168823,"y":-26.000019073486328},{"x":0.19849246740341187,"y":6.735236167907715},{"x":0.20351755619049072,"y":39.28663635253906},{"x":0.20854270458221436,"y":70.7453842163086},{"x":0.213567852973938,"y":100.25190734863281},{"x":0.21859294176101685,"y":127.02986907958984},{"x":0.22361809015274048,"y":150.408447265625},{"x":0.22864317893981934,"y":169.83152770996094},{"x":0.23366832733154297,"y":184.8596954345703},{"x":0.2386934757232666,"y":195.1669921875},{"x":0.24371856451034546,"y":200.54122924804688},{"x":0.2487437129020691,"y":200.88726806640625},{"x":0.2537688612937927,"y":196.2342071533203},{"x":0.2587939500808716,"y":186.74256896972656},{"x":0.2638190984725952,"y":172.7052764892578},{"x":0.2688441872596741,"y":154.53890991210938},{"x":0.2738693356513977,"y":132.76412963867188},{"x":0.27889448404312134,"y":107.97661590576172},{"x":0.2839195728302002,"y":80.81491088867188},{"x":0.28894472122192383,"y":51.93135070800781},{"x":0.29396986961364746,"y":21.972923278808594},{"x":0.2989949584007263,"y":-8.42682933807373},{"x":0.30402010679244995,"y":-38.6448974609375},{"x":0.3090451955795288,"y":-68.06080627441406},{"x":0.31407034397125244,"y":-96.04972076416016},{"x":0.3190954923629761,"y":-121.98282623291016},{"x":0.32412058115005493,"y":-145.23817443847656},{"x":0.32914572954177856,"y":-165.22067260742188},{"x":0.3341708183288574,"y":-181.38827514648438},{"x":0.33919596672058105,"y":-193.2766571044922},{"x":0.3442211151123047,"y":-200.51980590820312},{"x":0.34924620389938354,"y":-202.8599090576172},{"x":0.3542713522911072,"y":-200.1525421142578},{"x":0.3592965006828308,"y":-192.36566162109375},{"x":0.36432158946990967,"y":-179.58096313476562},{"x":0.3693467378616333,"y":-161.99903869628906},{"x":0.37437182664871216,"y":-139.95062255859375},{"x":0.3793969750404358,"y":-113.90949249267578},{"x":0.3844221234321594,"y":-84.50238037109375},{"x":0.3894472122192383,"y":-52.50864791870117},{"x":0.3944723606109619,"y":-18.843969345092773},{"x":0.39949744939804077,"y":15.472801208496094},{"x":0.4045225977897644,"y":49.36760330200195},{"x":0.40954774618148804,"y":81.76725769042969},{"x":0.4145728349685669,"y":111.6557388305664},{"x":0.4195979833602905,"y":138.12327575683594},{"x":0.42462313175201416,"y":160.4037322998047},{"x":0.429648220539093,"y":177.8991241455078},{"x":0.43467336893081665,"y":190.19503784179688},{"x":0.4396984577178955,"y":197.06886291503906},{"x":0.44472360610961914,"y":198.496337890625},{"x":0.4497487545013428,"y":194.6560516357422},{"x":0.45477384328842163,"y":185.93011474609375},{"x":0.45979899168014526,"y":172.8965301513672},{"x":0.4648240804672241,"y":156.3084716796875},{"x":0.46984922885894775,"y":137.05726623535156},{"x":0.4748743772506714,"y":116.12019348144531},{"x":0.47989946603775024,"y":94.49745178222656},{"x":0.4849246144294739,"y":73.14675903320312},{"x":0.4899497628211975,"y":52.9246826171875},{"x":0.49497485160827637,"y":34.54216003417969},{"x":0.5,"y":18.538436889648438}]},"encoding":{"x":{"field":"x","type":"quantitative"},"y":{"field":"y","title":"convolution","type":"quantitative"}},"mark":"line"}],"resolve":{"scale":{"y":"independent"}},"width":700}
```

In the plot above, we don't see any perturbation on top of the main period. The signal repeats itself 5 times during this 1s.

To confirm this, we plot the FFT of the convolution $(s\circledast f)(x)$.

It confirms that there is only one spike at 2Hz. This is what we wanted.

```elixir
n = 25
amplitudes = Nx.fft(y_conv_s_f) |> Nx.abs()

data_conv = %{
  x: (for i<- 0..n, do: i), 
  y: amplitudes[0..n] |> Nx.to_list() 
}

VegaLite.new(width: 700, height: 400)
|> VegaLite.layers([
  VegaLite.new()
  |> VegaLite.data_from_values(data_conv, only: ["x", "y"])
  |> VegaLite.mark(:bar)
  |> VegaLite.encode_field(:x, "x", type: :quantitative, title: "frequency bins")
  |> VegaLite.encode_field(:y, "y", type: :quantitative, title: "Ampliude")
])
```

<!-- livebook:{"output":true} -->

```vega-lite
{"$schema":"https://vega.github.io/schema/vega-lite/v5.json","height":400,"layer":[{"data":{"values":[{"x":0,"y":18.53924560546875},{"x":1,"y":34.354496002197266},{"x":2,"y":70.84143829345703},{"x":3,"y":147.5911407470703},{"x":4,"y":376.8251953125},{"x":5,"y":20019.13671875},{"x":6,"y":653.3214721679688},{"x":7,"y":429.0534973144531},{"x":8,"y":374.476318359375},{"x":9,"y":432.2054748535156},{"x":10,"y":587.4159545898438},{"x":11,"y":229.5377960205078},{"x":12,"y":99.92540740966797},{"x":13,"y":51.740142822265625},{"x":14,"y":24.753263473510742},{"x":15,"y":18.54645347595215},{"x":16,"y":22.41124153137207},{"x":17,"y":26.73343276977539},{"x":18,"y":30.53032684326172},{"x":19,"y":31.93748664855957},{"x":20,"y":22.824851989746094},{"x":21,"y":38.31175994873047},{"x":22,"y":37.67197036743164},{"x":23,"y":37.66423034667969},{"x":24,"y":37.44276809692383},{"x":25,"y":37.174564361572266}]},"encoding":{"x":{"field":"x","title":"frequency bins","type":"quantitative"},"y":{"field":"y","title":"Ampliude","type":"quantitative"}},"mark":"bar"}],"width":700}
```

#### Filter in the frequency domain and reverse

We now work in the frequency domain with the Fourier transform $\hat{s}(\omega)$ of the signal.

We apply a filter $\hat{f}$  in the frequency domain. This function will be equal to 1 for $f<f_c=10$ and 0 elsewhere.

The product $\hat{s} \cdot \hat{f}$  is therefor equivalent to take the $f_c=10$ first elements of $\hat{s}$ and right-pad/concatenante the truncated tensor with _zeros_.

We then take the _IFFT_ to return back to the time (or spatial) domain.

We see that we have removed the perturbation of frequency 20Hz as the base signal plot (at 5Hz, equivalently 5 periods per second) envelops nicely the IFFT values.

```elixir
n = 30; l = 10; fs = 200; start= -0.5; end_point = 0.5;
x = Nx.linspace(start, end_point, endpoint: false, n: fs, type: :f32)
s = C.sample(x)
fft = Nx.fft(s)

inverse = 
  Nx.pad(fft[0..l], 0, [{0,n-l, 0}])
  |> Nx.ifft() 
  |> Nx.real()
  

#-------- plot the IFFT
data = %{
  x: Nx.linspace(start, end_point, n: n+1, endpoint: false) |> Nx.to_list(),
  y: inverse[0..n] |> Nx.to_list()
}

#-------- fitting curve
xs = Nx.linspace(start, end_point, n: fs, endpoint: false)
signal = %{
  x: xs |> Nx.to_list(),
  y: C.base(xs) |> Nx.to_list()
}

VegaLite.new(height: 400, width: 700)
|> VegaLite.layers([
  VegaLite.new()
  |> VegaLite.data_from_values(data, only: ["x", "y"])
  |> VegaLite.mark(:bar)
  |> VegaLite.encode_field(:x, "x", type: :quantitative, title: "time(s)", scale: [domain: [-0.5, 0.5]])
  |> VegaLite.encode_field(:y, "y", type: :quantitative, title: "amplitutde"),
  VegaLite.new()
  |> VegaLite.data_from_values(signal, only: ["x", "y"])
  |> VegaLite.mark(:line)
  |> VegaLite.encode_field(:x, "x", type: :quantitative, title: "time(s)", scale: [domain: [-0.5, 0.5]])
  |> VegaLite.encode_field(:y, "y", type: :quantitative, title: "single signal"),
])
|> VegaLite.resolve(:scale, y: :independent)
```

<!-- livebook:{"output":true} -->

```vega-lite
{"$schema":"https://vega.github.io/schema/vega-lite/v5.json","height":400,"layer":[{"data":{"values":[{"x":-0.5,"y":5.830262352901627e-7},{"x":-0.4677419364452362,"y":-2.737560749053955},{"x":-0.4354838728904724,"y":-2.89613938331604},{"x":-0.4032258093357086,"y":-0.32634881138801575},{"x":-0.3709677457809448,"y":2.550886631011963},{"x":-0.33870968222618103,"y":3.025003671646118},{"x":-0.30645161867141724,"y":0.6493498682975769},{"x":-0.27419355511665344,"y":-2.338038921356201},{"x":-0.24193549156188965,"y":-3.1228296756744385},{"x":-0.20967742800712585,"y":-0.9656867980957031},{"x":-0.17741936445236206,"y":2.1012022495269775},{"x":-0.14516130089759827,"y":3.1886048316955566},{"x":-0.11290323734283447,"y":1.2721142768859863},{"x":-0.08064517378807068,"y":-1.842799425125122},{"x":-0.048387110233306885,"y":-3.2216646671295166},{"x":-0.01612904667854309,"y":-1.5654889345169067},{"x":0.016129016876220703,"y":1.5654898881912231},{"x":0.04838705062866211,"y":3.2216646671295166},{"x":0.08064514398574829,"y":1.8427990674972534},{"x":0.11290323734283447,"y":-1.2721192836761475},{"x":0.14516127109527588,"y":-3.1886065006256104},{"x":0.17741930484771729,"y":-2.1011979579925537},{"x":0.20967739820480347,"y":0.9656866788864136},{"x":0.24193549156188965,"y":3.1228299140930176},{"x":0.27419352531433105,"y":2.338040590286255},{"x":0.30645155906677246,"y":-0.6493512392044067},{"x":0.33870965242385864,"y":-3.0250065326690674},{"x":0.3709677457809448,"y":-2.5508878231048584},{"x":0.40322577953338623,"y":0.32635027170181274},{"x":0.43548381328582764,"y":2.896141290664673},{"x":0.4677419066429138,"y":2.7375617027282715}]},"encoding":{"x":{"field":"x","scale":{"domain":[-0.5,0.5]},"title":"time(s)","type":"quantitative"},"y":{"field":"y","title":"amplitutde","type":"quantitative"}},"mark":"bar"},{"data":{"values":[{"x":-0.5,"y":6.755324761797965e-7},{"x":-0.4950000047683716,"y":-0.1564338654279709},{"x":-0.49000000953674316,"y":-0.30901646614074707},{"x":-0.48500001430511475,"y":-0.4539892375469208},{"x":-0.47999998927116394,"y":-0.5877849459648132},{"x":-0.4749999940395355,"y":-0.7071065306663513},{"x":-0.4699999988079071,"y":-0.8090168237686157},{"x":-0.4650000035762787,"y":-0.8910059928894043},{"x":-0.46000000834465027,"y":-0.951056182384491},{"x":-0.45500001311302185,"y":-0.9876881837844849},{"x":-0.44999998807907104,"y":-1.0},{"x":-0.4449999928474426,"y":-0.9876883625984192},{"x":-0.4399999976158142,"y":-0.9510567784309387},{"x":-0.4350000023841858,"y":-0.8910068869590759},{"x":-0.4300000071525574,"y":-0.8090174198150635},{"x":-0.42500001192092896,"y":-0.7071073055267334},{"x":-0.42000001668930054,"y":-0.5877864956855774},{"x":-0.41499999165534973,"y":-0.45399099588394165},{"x":-0.4099999964237213,"y":-0.30901744961738586},{"x":-0.4050000011920929,"y":-0.15643487870693207},{"x":-0.4000000059604645,"y":-3.4969110629390343e-7},{"x":-0.39500001072883606,"y":0.15643323957920074},{"x":-0.38999998569488525,"y":0.30901679396629333},{"x":-0.38499999046325684,"y":0.4539903998374939},{"x":-0.3799999952316284,"y":0.5877851843833923},{"x":-0.375,"y":0.7071061134338379},{"x":-0.3700000047683716,"y":0.8090164661407471},{"x":-0.36500000953674316,"y":0.8910061120986938},{"x":-0.36000001430511475,"y":0.9510563015937805},{"x":-0.35500001907348633,"y":0.9876882433891296},{"x":-0.3500000238418579,"y":1.0},{"x":-0.3449999988079071,"y":0.987688422203064},{"x":-0.3400000035762787,"y":0.9510566592216492},{"x":-0.33500000834465027,"y":0.8910067677497864},{"x":-0.32999998331069946,"y":0.8090167045593262},{"x":-0.32499998807907104,"y":0.7071070671081543},{"x":-0.3199999928474426,"y":0.587785542011261},{"x":-0.3149999976158142,"y":0.45399072766304016},{"x":-0.3100000023841858,"y":0.309017151594162},{"x":-0.3050000071525574,"y":0.1564355045557022},{"x":-0.30000001192092896,"y":9.775241096576792e-7},{"x":-0.29500001668930054,"y":-0.156433567404747},{"x":-0.2900000214576721,"y":-0.3090161979198456},{"x":-0.2850000262260437,"y":-0.45398980379104614},{"x":-0.2800000011920929,"y":-0.5877847075462341},{"x":-0.2750000059604645,"y":-0.707106351852417},{"x":-0.27000001072883606,"y":-0.8090166449546814},{"x":-0.26499998569488525,"y":-0.8910067677497864},{"x":-0.25999999046325684,"y":-0.9510563611984253},{"x":-0.2549999952316284,"y":-0.9876883029937744},{"x":-0.25,"y":-1.0},{"x":-0.24500000476837158,"y":-0.9876883625984192},{"x":-0.24000000953674316,"y":-0.951056718826294},{"x":-0.23500001430511475,"y":-0.8910068273544312},{"x":-0.23000001907348633,"y":-0.8090175986289978},{"x":-0.22499999403953552,"y":-0.7071068286895752},{"x":-0.2199999988079071,"y":-0.5877856016159058},{"x":-0.2150000035762787,"y":-0.4539908766746521},{"x":-0.21000000834465027,"y":-0.30901771783828735},{"x":-0.20500001311302185,"y":-0.15643517673015594},{"x":-0.20000001788139343,"y":-6.516827397717861e-7},{"x":-0.19499999284744263,"y":0.15643435716629028},{"x":-0.1899999976158142,"y":0.30901697278022766},{"x":-0.1850000023841858,"y":0.4539901316165924},{"x":-0.18000000715255737,"y":0.5877849459648132},{"x":-0.17500001192092896,"y":0.7071061730384827},{"x":-0.17000001668930054,"y":0.8090165257453918},{"x":-0.16500002145767212,"y":0.8910062313079834},{"x":-0.1599999964237213,"y":0.9510564804077148},{"x":-0.1550000011920929,"y":0.9876883029937744},{"x":-0.15000000596046448,"y":1.0},{"x":-0.14500001072883606,"y":0.987688422203064},{"x":-0.14000001549720764,"y":0.9510567784309387},{"x":-0.13500002026557922,"y":0.8910068869590759},{"x":-0.12999999523162842,"y":0.8090171813964844},{"x":-0.125,"y":0.70710688829422},{"x":-0.12000000476837158,"y":0.587785542011261},{"x":-0.11500000953674316,"y":0.45399099588394165},{"x":-0.11000001430511475,"y":0.3090176582336426},{"x":-0.10500001907348633,"y":0.15643508732318878},{"x":-0.10000002384185791,"y":8.026785280890181e-7},{"x":-0.0949999988079071,"y":-0.15643444657325745},{"x":-0.09000000357627869,"y":-0.3090168237686157},{"x":-0.08500000834465027,"y":-0.45399022102355957},{"x":-0.08000001311302185,"y":-0.5877848267555237},{"x":-0.07500001788139343,"y":-0.7071062922477722},{"x":-0.07000002264976501,"y":-0.8090164661407471},{"x":-0.06499999761581421,"y":-0.8910064697265625},{"x":-0.06000000238418579,"y":-0.9510564804077148},{"x":-0.05500000715255737,"y":-0.9876883029937744},{"x":-0.050000011920928955,"y":-1.0},{"x":-0.04500001668930054,"y":-0.987688422203064},{"x":-0.04000002145767212,"y":-0.951056718826294},{"x":-0.034999996423721313,"y":-0.8910065293312073},{"x":-0.030000001192092896,"y":-0.8090170621871948},{"x":-0.025000005960464478,"y":-0.7071069478988647},{"x":-0.02000001072883606,"y":-0.5877856016159058},{"x":-0.015000015497207642,"y":-0.45399096608161926},{"x":-0.010000020265579224,"y":-0.3090176582336426},{"x":-0.005000025033950806,"y":-0.1564352661371231},{"x":0.0,"y":0.0},{"x":0.004999995231628418,"y":0.1564343422651291},{"x":0.009999990463256836,"y":0.30901673436164856},{"x":0.014999985694885254,"y":0.4539901316165924},{"x":0.019999980926513672,"y":0.5877848267555237},{"x":0.02499997615814209,"y":0.707106351852417},{"x":0.029999971389770508,"y":0.8090165257453918},{"x":0.034999966621398926,"y":0.8910060524940491},{"x":0.039999961853027344,"y":0.951056182384491},{"x":0.04500001668930054,"y":0.987688422203064},{"x":0.050000011920928955,"y":1.0},{"x":0.05500000715255737,"y":0.9876883029937744},{"x":0.06000000238418579,"y":0.9510564804077148},{"x":0.06499999761581421,"y":0.8910064697265625},{"x":0.06999999284744263,"y":0.80901700258255},{"x":0.07499998807907104,"y":0.7071069478988647},{"x":0.07999998331069946,"y":0.5877856016159058},{"x":0.08499997854232788,"y":0.4539910554885864},{"x":0.0899999737739563,"y":0.30901771783828735},{"x":0.09499996900558472,"y":0.15643540024757385},{"x":0.09999996423721313,"y":1.104670104723482e-6},{"x":0.10499995946884155,"y":-0.15643344819545746},{"x":0.11000001430511475,"y":-0.3090176582336426},{"x":0.11500000953674316,"y":-0.45399099588394165},{"x":0.12000000476837158,"y":-0.587785542011261},{"x":0.125,"y":-0.70710688829422},{"x":0.12999999523162842,"y":-0.8090171813964844},{"x":0.13499999046325684,"y":-0.8910064697265625},{"x":0.13999998569488525,"y":-0.9510564804077148},{"x":0.14499998092651367,"y":-0.9876882433891296},{"x":0.1499999761581421,"y":-1.0},{"x":0.1549999713897705,"y":-0.9876884818077087},{"x":0.15999996662139893,"y":-0.9510567784309387},{"x":0.16499996185302734,"y":-0.8910068869590759},{"x":0.16999995708465576,"y":-0.8090176582336426},{"x":0.17500001192092896,"y":-0.7071061730384827},{"x":0.18000000715255737,"y":-0.5877849459648132},{"x":0.1850000023841858,"y":-0.4539901316165924},{"x":0.1899999976158142,"y":-0.30901697278022766},{"x":0.19499999284744263,"y":-0.15643435716629028},{"x":0.19999998807907104,"y":-3.019916050561733e-7},{"x":0.20499998331069946,"y":0.15643423795700073},{"x":0.20999997854232788,"y":0.3090168237686157},{"x":0.2149999737739563,"y":0.45398998260498047},{"x":0.21999996900558472,"y":0.5877848863601685},{"x":0.22499996423721313,"y":0.7071061730384827},{"x":0.22999995946884155,"y":0.8090164661407471},{"x":0.23499995470046997,"y":0.8910059332847595},{"x":0.24000000953674316,"y":0.951056718826294},{"x":0.24500000476837158,"y":0.9876883625984192},{"x":0.25,"y":1.0},{"x":0.2549999952316284,"y":0.9876883029937744},{"x":0.25999999046325684,"y":0.9510563611984253},{"x":0.26499998569488525,"y":0.8910067677497864},{"x":0.26999998092651367,"y":0.8090171813964844},{"x":0.2749999761581421,"y":0.7071070075035095},{"x":0.2799999713897705,"y":0.5877854228019714},{"x":0.2849999666213989,"y":0.45399150252342224},{"x":0.28999996185302734,"y":0.30901801586151123},{"x":0.29499995708465576,"y":0.15643545985221863},{"x":0.2999999523162842,"y":9.298245799982396e-7},{"x":0.3050000071525574,"y":-0.1564355045557022},{"x":0.3100000023841858,"y":-0.309017151594162},{"x":0.3149999976158142,"y":-0.45399072766304016},{"x":0.3199999928474426,"y":-0.587785542011261},{"x":0.32499998807907104,"y":-0.7071070671081543},{"x":0.32999998331069946,"y":-0.8090167045593262},{"x":0.3349999785423279,"y":-0.8910062909126282},{"x":0.3399999737739563,"y":-0.9510563611984253},{"x":0.3449999690055847,"y":-0.9876883029937744},{"x":0.34999996423721313,"y":-1.0},{"x":0.35499995946884155,"y":-0.9876885414123535},{"x":0.35999995470046997,"y":-0.9510568380355835},{"x":0.36500000953674316,"y":-0.8910061120986938},{"x":0.3700000047683716,"y":-0.8090164661407471},{"x":0.375,"y":-0.7071061134338379},{"x":0.3799999952316284,"y":-0.5877851843833923},{"x":0.38499999046325684,"y":-0.4539903998374939},{"x":0.38999998569488525,"y":-0.30901679396629333},{"x":0.39499998092651367,"y":-0.15643419325351715},{"x":0.3999999761581421,"y":-6.039832101123466e-7},{"x":0.4049999713897705,"y":0.15643393993377686},{"x":0.4099999666213989,"y":0.30901652574539185},{"x":0.41499996185302734,"y":0.4539901614189148},{"x":0.41999995708465576,"y":0.5877849459648132},{"x":0.4249999523162842,"y":0.7071059942245483},{"x":0.4300000071525574,"y":0.8090174198150635},{"x":0.4350000023841858,"y":0.8910068869590759},{"x":0.4399999976158142,"y":0.9510567784309387},{"x":0.4449999928474426,"y":0.9876883625984192},{"x":0.44999998807907104,"y":1.0},{"x":0.45499998331069946,"y":0.9876883029937744},{"x":0.4599999785423279,"y":0.9510564804077148},{"x":0.4649999737739563,"y":0.8910064101219177},{"x":0.4699999690055847,"y":0.8090173602104187},{"x":0.47499996423721313,"y":0.7071072459220886},{"x":0.47999995946884155,"y":0.5877856612205505},{"x":0.48499995470046997,"y":0.45399096608161926},{"x":0.4899999499320984,"y":0.3090182840824127},{"x":0.4950000047683716,"y":0.1564338654279709}]},"encoding":{"x":{"field":"x","scale":{"domain":[-0.5,0.5]},"title":"time(s)","type":"quantitative"},"y":{"field":"y","title":"single signal","type":"quantitative"}},"mark":"line"}],"resolve":{"scale":{"y":"independent"}},"width":700}
```

## Example: polynomial multiplication using convolution

You can use the convolution product to compute the coefficients of the product of two polynomials.

<!-- livebook:{"break_markdown":true} -->

Lets visualize the convolution product.

Take two polynomials $P_1 = 1+X+X^2$ and $P_2=2+X$. There product is:

$$2+2X+3X^2+X^3+X^4$$

We calculate the convolution of $P_1=[1,1,1]$ with $P_2=[1,0,2]$ (the "kernel" is reversed here).

We are going to slide $P_2$ below $P_1$ and sum the term by term product with the rule that $P_2$ always overlaps $P_1$ by at least one term. This gives us 5 possibilities.

We therefor pad the first tensor with 2 zeros to the left and to the right, in order to calculate 5 sums of 3 products.

<!-- livebook:{"break_markdown":true} -->

```
t1           0 0 1 1 1 0 0
rev(t2)      1 0 2            0x1 + 0x0 + 1x2 = 2
               1 0 2          0x1 + 1x0 + 1x2 = 2
                 1 0 2        1x1 + 1x0 + 1x2 = 3
                   1 0 2      1x1 + 1x0 + 0x2 = 1
                     1 0 2    1x1 + 0x0 + 0x2 = 1

               2 2 3 1 1 
```

<!-- livebook:{"break_markdown":true} -->

We will apply a padding +2 "zeros" to the left and the right of the first tensor in the `Nx.conv` function.

```elixir
defmodule NxPoly do
  import Nx.Defn
  
  defn tprod(t1, t2) do
    t1 = Nx.stack(t1) |> Nx.as_type(:f32)
    t1 = Nx.reshape(t1, {1,1, Nx.size(t1)})
    t2 = Nx.stack(t2) |> Nx.as_type(:f32)
    t2 = Nx.reshape(t2, {1,1, Nx.size(t2)})
    
    Nx.conv(t1, Nx.reverse(t2), padding: [{2,2}])
  end
end

```

<!-- livebook:{"output":true} -->

```
{:module, NxPoly, <<70, 79, 82, 49, 0, 0, 10, ...>>, true}
```

```elixir
NxPoly.tprod([1,1,1], [2,0,1])
|> Nx.as_type(:u8)
|> Nx.flatten()
|> Nx.to_list()
```

<!-- livebook:{"output":true} -->

```
[2, 2, 3, 1, 1]
```

We obtain the coefficients of the product: $2 + 2X + 3X^2 + X^3 + X^4$

## Example: edge detector with a discret differential kernel

The MNIST dataset contains images of numbers from 0 to 255 organized row wise with a format 28x28 pixels with 1 channel (grey levels).

This means that the pixel $(i,j)$ is at the $i$-th row and $ j$-th column.

```elixir
{{images_binary, type, images_shape} = _train_images, train_labels} = Scidata.MNIST.download_test()
{labels, {:u,8}, label_shape} = train_labels

images = images_binary |> Nx.from_binary(type) |> Nx.reshape(images_shape)

{{_nb, _channel, _height, _width}, _type}  = {images_shape, type}
```

<!-- livebook:{"output":true} -->

```
{{10000, 1, 28, 28}, {:u, 8}}
```

The labels describe what the image is. The 15th image is a "5".

```elixir
Nx.from_binary(labels, :u8)[15] |> Nx.to_number()
```

<!-- livebook:{"output":true} -->

```
5
```

To be sure, we display this image with `StbImage`.

> We transform the tensor as `StbImage` expects the format {height, width, channel} whilst the MNIST uses {channel, height, width}.

```elixir
five = images[15] 

Nx.transpose(five, axes: [1,2,0])
|> StbImage.from_nx()
|> StbImage.resize(500, 500)
```

<!-- livebook:{"output":true} -->

```
%StbImage{
  data: <<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...>>,
  shape: {500, 500, 1},
  type: {:u, 8}
}
```

We can __detect edges__ by performing a discrete differentiation, where the kernel computes the difference between adjacent pixel values. This can be viewed as a discrete approximation of a derivative.

Since the image is slightly blurred, we use a stride of 2, allowing us to skip over intermediate pixels. The kernel is defined as $[-1,0,1]$, which calculates the difference between pixel values separated by two units.

This operation can be applied along the width axis to detect vertical edges or along the height axis to detect horizontal edges.

Given pixel coordinates $(i,j)$ where $i$ is the row and $j$ the column, we compute:

* vertical edges with horizontally adjacent pixels : $\mathrm{pix}(i, j) \cdot (-1) +  \mathrm{pix}(i, j+2) \cdot (1)$ and the kernel will be reshaped into $ {1,1,1,3}$.

* horizontal edges with vertically adjacent pixels: $\mathrm{pix}(i, j) \cdot (-1) +  \mathrm{pix}(i+2, j) \cdot (1)$ and the kernel will be reshaped into $ {1,1,3, 1}$

Below, we compute two transformed images using these vertical and horizontal edge detectors and display the results.

```elixir
edge_kernel = Nx.tensor([-1, 0, 1]) 

vertical_detection = Nx.conv(
  Nx.reshape(five, {1, 1, 28, 28}) |> Nx.as_type(:f32), 
  Nx.reshape(edge_kernel, {1, 1, 1, 3}), 
  padding: :same
)

horizontal_detection = Nx.conv(
  Nx.reshape(five, {1, 1, 28, 28}) |> Nx.as_type(:f32), 
   Nx.reshape(edge_kernel, {1, 1, 3, 1}), 
  padding: :same
)

Nx.concatenate([vertical_detection, horizontal_detection], axis: -1)
|> Nx.reshape({28, 56, 1}) 
|> Nx.as_type({:u, 8}) 
|> StbImage.from_nx()
|> StbImage.resize(500, 1000)
```

<!-- livebook:{"output":true} -->

```
%StbImage{
  data: <<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...>>,
  shape: {500, 1000, 1},
  type: {:u, 8}
}
```

## Recover the kernel knowing the output

Suppose we have an image and its corresponding transformed version, produced by a convolution.

Our goal is to recover the convolution kernel "by hand". The will use a simple gradient descent approach.

This involves iteratively updating the kernel through an optimization process. The update to the kernel is proportional to the gradient of a loss function, which we aim to minimize.

The loss function measures the difference between the known output (referred to as vertical_convolution in this case) and the current output image, computed as `Nx.conv(input, current_kernel)`.

We start with an initial kernel of zeros, working with floats instead of integers.

The algorithm uses a parameter `eps` to control the step size (rate of change) during each iteration. This parameter is critical for achieving stable convergence:

* If `eps` is too large, the iterations may become unstable.
* If `eps` is too small, the process may become slow and could converge to a local minimum instead of a potential global optimum (as no convexity is assumed here).

```elixir
five = Nx.reshape(five, {1, 1, 28, 28})
kernel_init = Nx.tensor([0.0, 0.0, 0.0]) |> Nx.reshape({1,1,1,3})

defmodule GradDesc do
  import Nx.Defn

  defn curr_loss(input, kernel, out) do
    curr_out = Nx.conv(input |> Nx.as_type(:f32), kernel, padding: :same)
    Nx.mean((curr_out - out)**2)
  end

  defn update(kernel, input, out, opts) do
    der = grad(kernel, fn t -> curr_loss(input, t,  out) end)
    kernel - der * opts[:eps]
  end

  defn loop(input, kernel, output, opts) do
    {k,_, _,_} = 
      # for simplicity, we only set the number of steps to run.
      while {k = kernel, i=0, inp=input, out=output}, i <= opts[:itermax]  do
        {update(k, inp, out, opts), i+1, inp, out}
      end
    {k, curr_loss(input, k,  output)}
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, GradDesc, <<70, 79, 82, 49, 0, 0, 19, ...>>, true}
```

```elixir
IO.puts("Initial loss: #{round(Nx.to_number(GradDesc.curr_loss(five, kernel_init, vertical_detection)))}")

{k, loss} = GradDesc.loop(five, kernel_init, vertical_detection, itermax: 10, eps: 1.0e-4)

IO.puts("Loss after iterations: #{Nx.to_number(loss)}")
```

<!-- livebook:{"output":true} -->

```
Initial loss: 4647
Loss after iterations: 0.004979725461453199
```

<!-- livebook:{"output":true} -->

```
:ok
```

We expect to find a kernel close to $ [-1,0,1]$ after 10 iterations with a learning rate of 1e-4.

```elixir
Nx.to_list(k)|> List.flatten()
```

<!-- livebook:{"output":true} -->

```
[-0.9989683032035828, -3.817594006250147e-6, 0.998961329460144]
```

## Using an Axon model with a convolution layer to predict vertical edges

Let's use `Axon` to recover the convolution kernel. Our model will consist of a single convolution layer.

We will give to our model a series of images and its transform (by the "known" kernel).

The first 15 images do not contain the number 5. We will apply the "vertical" convolution transform to these images and feed them to the model to help it "learn" how to detect vertical edges.

```elixir
# we produce a sample of 14 tuples {input, output = conv(input, kernel)} 
# which contain some numbers (different from 5)
l = 14
kernel = Nx.tensor([-1.0,0.0,1.0])  |> Nx.reshape({1,1,1,3}) 

training_data = 
  images[0..l] 
  |> Nx.reshape({l+1, 1,28,28})
  |> Nx.as_type(:f32)
  |> Nx.to_batched(1)
  |> Stream.map(fn img -> 
    {img, Nx.conv(img, kernel, padding: :same)} 
  end)
```

<!-- livebook:{"output":true} -->

```
#Stream<[
  enum: 0..14,
  funs: [#Function<50.105594673/1 in Stream.map/2>, #Function<50.105594673/1 in Stream.map/2>]
]>
```

The model is a simple convolution layer:

```elixir
model = 
  Axon.input("x", shape: {nil, 1, 28, 28})
  |> Axon.conv(1, 
    channels: :first, 
    padding: :same, 
    kernel_initializer: :zeros, 
    use_bias: false, 
    kernel_size: 3
  )
```

<!-- livebook:{"output":true} -->

```
#Axon<
  inputs: %{"x" => {nil, 1, 28, 28}}
  outputs: "conv_0"
  nodes: 2
>
```

We train the model with the dataset. Note that it is important to use `compiler: EXLA` for the computation speed.

```elixir
optimizer = Polaris.Optimizers.adam(learning_rate: 1.0e-2)
#optimizer = Polaris.Optimizers.adabelief(learning_rate: 1.0e-2)

params = 
  Axon.Loop.trainer(model, :mean_squared_error, optimizer)
  |> Axon.Loop.run(training_data, Axon.ModelState.empty(), epochs: 20,  compiler: EMLX)
```

<!-- livebook:{"output":true} -->

```

00:06:22.750 [debug] Forwarding options: [compiler: EMLX] to JIT compiler
Epoch: 0, Batch: 0, loss: 0.0000000
Epoch: 1, Batch: 0, loss: 4096.1328125
Epoch: 2, Batch: 0, loss: 2760.1577148
Epoch: 3, Batch: 0, loss: 2029.4346924
Epoch: 4, Batch: 0, loss: 1624.6121826
Epoch: 5, Batch: 0, loss: 1374.7448730
Epoch: 6, Batch: 0, loss: 1202.8275146
Epoch: 7, Batch: 0, loss: 1075.4884033
Epoch: 8, Batch: 0, loss: 976.2915649
Epoch: 9, Batch: 0, loss: 895.9644165
Epoch: 10, Batch: 0, loss: 828.9739990
Epoch: 11, Batch: 0, loss: 771.8309326
Epoch: 12, Batch: 0, loss: 722.2226563
Epoch: 13, Batch: 0, loss: 678.5550537
Epoch: 14, Batch: 0, loss: 639.6925049
Epoch: 15, Batch: 0, loss: 604.8014526
Epoch: 16, Batch: 0, loss: 573.2542725
Epoch: 17, Batch: 0, loss: 544.5662842
Epoch: 18, Batch: 0, loss: 518.3546143
Epoch: 19, Batch: 0, loss: 494.3110657
```

<!-- livebook:{"output":true} -->

```
#Axon.ModelState<
  Parameters: 9 (36 B)
  Trainable Parameters: 9 (36 B)
  Trainable State: 0, (0 B)
>
```

We can now check what our Axon model learnt. We compare:

* its "vertical"-convolution
* the predicted image by our model.

```elixir
five =  Nx.reshape(images[15], {1,1,28,28}) |> Nx.as_type(:f32)

model_five = 
  Axon.predict(model, params, five)

conv_five = Nx.conv(
  Nx.reshape(images[15] , {1, 1, 28, 28}) |> Nx.as_type(:f32), 
  Nx.reshape(edge_kernel , {1, 1, 1, 3}), 
  padding: :same
)

Nx.concatenate([model_five, conv_five], axis: -1)
|> Nx.reshape({28, 56, 1}) 
|> Nx.clip(0,255)
|> Nx.as_type(:u8)
|> StbImage.from_nx()
|> StbImage.resize(500, 1500)
```

<!-- livebook:{"output":true} -->

```
%StbImage{
  data: <<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...>>,
  shape: {500, 1500, 1},
  type: {:u, 8}
}
```

## Convolution live example

We aim to apply a blurring filter to our webcam feed.

This is achieved by convolving the image with a Gaussian kernel, which computes a weighted average (the "Gaussian mean") of the pixels within the kernel's area.

Most of the tensor manipulations used below are explained in this post:

<https://dockyard.com/blog/2022/03/15/nx-for-absolute-beginners>

#### The gaussian kernel

Lets walk through how the blur kernel is constructed:

Inputs: Start with a desired kernel_size and a standard deviation sigma.
Generate Vectors: Create two vectors x and y of integers, centered at 0, with lengths equal to the next odd number greater than or equal to kernel_size.
For example, if kernel_size is 4, the vectors will be [-2, -1, 0, 1, 2].
If kernel_size is 5, the vectors remain the same (to ensure 0 is in the center).
Calculate Gaussian Coefficients: For each pair of values $(_i, y_j)$ from the vectors, compute the Gaussian coefficient:

Let's see how the "blur" kernel is built.

* given a desired `kernel_size` and the mean `sigma`,
* it produces two vectors of integers `x` and `y` centered at 0 and of length the next odd number. For example, if the size is 4, it produces two vectors `[-2, -1, 0, 1, 2]`. If the size is 5, it produces the same two vectors (you want 0 to be "in the middle")
* you then use all the couples $(x_i,y_j)$ from these two vectors to compute the gaussian coefficients. For example with a size of 4, you will get 5x5=25 gaussian coefficients.
  $$
  \dfrac1{2\pi\sigma^2}\cdot \exp^{\big(\dfrac{-x_i^2+y_j^2}{2\sigma}\big)}
  $$
* For a kernel size of 4, this results in 5x5=25 Gaussian coefficients.
* Normalize: Scale the coefficients so their sum equals 1. This ensures that the resulting kernel preserves the overall brightness of the image.

#### The convolution

We then perform a convolution between the input (a tensor representing an image) and the given kernel.

The input is expected to have the shape `{height, width, channel}` and a data type of `:u8`, representing integers ranging from 0 to 255. For example, a 256x256 color PNG image would have the shape `{256, 256, 4}`, where the 4 channels correspond to RGBA values.

To prepare the image for computation, the tensor is converted to floats in the range [0, 1] by dividing each element by 255.

To reduce the computational load, we process only every second pixel. This effectively downsamples the image from, for example, 256x256 to 128x128. This is achieved using strides [2, 2], which skip every other row and column.

As noted earlier, the convolution operation expects the input format `{batch_size, channel, dim_1, dim_2, ...}`.

To accommodate this, we batch the computations by color channel. First, we add an additional dimension to the tensor using `Nx.axis_new`, and then permute the axes to bring the channel dimension into the batch position. This transforms the tensor from `{256, 256, 4}` to `{4, 1, 256, 256}`. The permutation is specified using the `input_permutation` parameter.

Once the convolution is complete:

* The extra singleton dimension is removed using `Nx.squeeze`.
* The resulting floats are rescaled back to the range [0, 255].
* The values are rounded to the nearest integer and cast back to the type `:u8`, as integers are required to produce a valid RGB image.

```elixir
# PValente filters

defmodule Filter do
  import Nx.Defn
  import Nx.Constants, only: [pi: 0]

  deftransform get_odd_size(opts) do
    size = opts[:kernel_size]
    size + 1 - rem(size, 2)
  end

  defn gaussian_blur_kernel(opts \\ []) do
    opts = keyword!(opts, [:kernel_size, :sigma])
    sigma = opts[:sigma]
    size = get_odd_size(opts)

    half_size = div(size, 2)

    range = {size} |> Nx.iota() |> Nx.subtract(half_size)

    x = Nx.vectorize(range, :x)
    y = Nx.vectorize(range, :y)

    # Apply Gaussian function to each element
    kernel =
      Nx.exp(-(x * x + y * y) / (2 * sigma * sigma))

    kernel = kernel / (2 * pi() * sigma * sigma)

    kernel = Nx.devectorize(kernel)

    # Normalize the kernel so the sum is 1
    kernel / Nx.sum(kernel)
  end

  defn apply_kernel(image, kernel, opts \\ []) do
    # you work on half of the image, reducing from 256 to 128 with strides: [2,2]
    opts = keyword!(opts, strides: [2, 2])

    # assumes channels are last in the image
    input_type = Nx.type(image)
    # use floats in [0..1] instead of u8 in [0..255]
    image = image / 255

    {m, n} = Nx.shape(kernel)
    kernel = Nx.reshape(kernel, {1,1,m,n})

    image
    # insert a new dimension: on the contrary to reshape, you don't need to use the current shape
    |> Nx.new_axis(0)
    |> Nx.conv(kernel,
      padding: :same,
      # swap {1, h, w, c} to {c, 1, h, w} for the calculations to be batched on each colour
      input_permutation: [3, 0, 1, 2],
      output_permutation: [3, 0, 1, 2],
      strides: opts[:strides]
    )
    |> Nx.squeeze(axes: [0])
    |> Nx.multiply(255)
    |> Nx.clip(0, 255)
    |> Nx.as_type(input_type)
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, Filter, <<70, 79, 82, 49, 0, 0, 23, ...>>, true}
```

We can take a look into a kernel:

```elixir
Filter.gaussian_blur_kernel(kernel_size: 3, sigma: 0.5)
```

<!-- livebook:{"output":true} -->

```
#Nx.Tensor<
  f32[x: 3][y: 3]
  EMLX.Backend<gpu, 0.1937529058.1490157571.225489>
  [
    [0.011343738064169884, 0.08381950855255127, 0.011343738064169884],
    [0.08381950855255127, 0.6193470358848572, 0.08381950855255127],
    [0.011343738064169884, 0.08381950855255127, 0.011343738064169884]
  ]
>
```

The code below in a custom `Kino.JS.Live` module. It captures the embedded webcam feed from your computer and produces a blurred version using the convolution module defined above.

The JavaScript code captures frames from the webcam into an `OffscreenCanvas`. Every other frame is processed with a convolution filter, and the resulting frame is sent to the Elixir backend as a binary. Kino.JS.Live simplifies this process using a WebSocket and the `pushEvent` mechanism that accepts binary data.

The binary output of the convolution is converted to JPEG (:jpg) format, offering better compression than PNG (:png)typically achieving a compression ratio of around 1:4.

This compressed binary is then sent back to the JavaScript client via a WebSocket using the `broadcast_event` function on the server side and the `handleEvent` callback on the client side.

To restore the original resolution of 256x256 (after reducing it to 128x128 for processing), the canvas.drawImage function is used, specifying both the source and target dimensions.

```elixir
defmodule Streamer do
  use Kino.JS
  use Kino.JS.Live

  def html() do
    """
    <video id= "invid"></video>
    <canvas id="canvas" width="256" height="256"></canvas>
    """
  end

  def start(), do: Kino.JS.Live.new(__MODULE__, html())

  @impl true
  def handle_connect(ctx), do: {:ok, ctx.assigns.html, ctx}

  @impl true
  def init(html, ctx), do: {:ok, assign(ctx, html: html)}

  # it receives a video frame in binary form
  @impl true
  def handle_event("new frame", {:binary,_, buffer}, ctx) do
    image = 
      Nx.from_binary(buffer, :u8) 
      # change shape from {1, 262144} to {256, 256, 4}
      |> Nx.reshape({256, 256, 4})

    # apply a {5,5} gaussian kernel
    kernel = Filter.gaussian_blur_kernel(kernel_size: 5, sigma: 1)   
    
    output = 
      Filter.apply_kernel(image, kernel) 
      |> StbImage.from_nx()
      |> StbImage.to_binary(:jpg)
    
    broadcast_event(ctx, "processed_frame", {:binary, %{}, output})
    {:noreply, ctx}
  end

  asset "main.js" do
    """
    export async function init(ctx, html) {
      ctx.root.innerHTML = html;
    
      const height = 256, width = 256,
        video = document.getElementById("invid"),
        renderCanvas = document.getElementById("canvas"),
        renderCanvasCtx = renderCanvas.getContext("2d"),
        offscreen = new OffscreenCanvas(width, height),
        offscreenCtx = offscreen.getContext("2d", { willReadFrequently: true });

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width, height },
        });
        video.srcObject = stream;
        let frameCounter = 0;
        video.play();
    
        const processFrame = async (_now, _metadata) => {
          frameCounter++;
          // process only 1 frame out of 2
          if (frameCounter % 2 == 0) {
            offscreenCtx.drawImage(video, 0, 0, width, height);
            const {data}  = offscreenCtx.getImageData(0, 0, width, height);
            ctx.pushEvent("new frame", [{}, data.buffer]);
          }
          requestAnimationFrame(processFrame);
        };
    
        requestAnimationFrame(processFrame);
      } catch (err) {
        console.error("Webcam access error:", err);
      }

      ctx.handleEvent("processed_frame", async ([{}, binary]) => {
        const bitmap = await createImageBitmap(new Blob([binary], { type: "image/jpeg" }));
        renderCanvasCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0,0, 256,256)
      });
    }
    """
  end
end

```

<!-- livebook:{"output":true} -->

```
{:module, Streamer, <<70, 79, 82, 49, 0, 0, 17, ...>>, :ok}
```

```elixir
Streamer.start()
```

As a side note, the [webGPU API](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API) is available, meaning that the browser is able to call directly the GPU to run computations.

## Convolution and music

# Discrete Fourrier Transform with Nx

```elixir
Mix.install([
  {:nx, "~> 0.9.1"},
  {:kino, "~> 0.14.2"},
  {:kino_vega_lite, "~> 0.1.11"},
  {:exla, "~> 0.9.1"}
], config: [nx: [default_backend: EXLA.Backend]]
)

Nx.Defn.global_default_options(compiler: EXLA, client: :host)
```

## Using complex numbers

Take the complex number $1+i$.

Since `Nx` brings in the library `Complex`, we define a complex number by `Complex.new/1`:

```elixir
one = Complex.new(1,1)
```

Its norm is $ \sqrt{2}$, and angle is $\pi/4$.

Its polar form is:

$ \sqrt{2}\big(\cos(\pi/4) + i\sin(\pi/4)\big) = \sqrt{2} \exp^{i \pi/4}$.

We can use `Complex.from_polar/2`:

```elixir
sqrt_2 = :math.sqrt(2)
a = :math.pi()/4

cx_one = Complex.from_polar(sqrt_2, a)
```

We can also use `Nx` to build a complex:

```elixir
t_one = Nx.complex(Nx.tensor(1), Nx.tensor(1))
```

and compute its norm:

```elixir
Nx.abs(t_one)
```

We also have:

```elixir
i = Nx.Constants.i()

Nx.add(1 , i)
```

## Discrete Fourrier Transform

Suppose we have a periodic signal that we sample in order to understand it.

We will run a Fast Fourrier Taansform. It transforms a time-domain function into the frequency domain.

<https://en.wikipedia.org/wiki/Discrete_Fourier_transform>

<!-- livebook:{"break_markdown":true} -->

Lets build a signal that we want to discover!

It will be the sum of three sinusoid signals, one at 5Hz, one at 15Hz and a last one at 20Hz with the corresponding amplitudes (1, 0.5, 0.25).

$\sin(2\pi*5*t / f_s) + \frac12 \sin(2\pi*15*t/f_s) + \frac14 \sin(2\pi*20*t/f_S)$

Suppose our sampling rate is `fs` Hz (meaning `fs` samples per second). We build a linear space of 64 equally spaced points with `Nx.linspace`. For each value of the discrete time $t$, we will calculate the "hidden" signal at $t$ in our "Signal" module. This will give us the sampling.

```elixir
defmodule Signal do
  import Nx.Defn

  defn pi(), do: Nx.Constants.pi()


  defn sample(opts) do
    fs = opts[:fs]
    sampling = Nx.linspace(0, fs, n: fs, endpoint: false, type: {:u, 64})
    f1 = 5
    f2 = 15
    f3 = 20
    Nx.sin(2 * pi() * f1 * sampling / fs) + 1/2 * Nx.sin(2 * pi() * f2 * sampling / fs) + 1/4 * Nx.sin(2 * pi() * f3 * sampling / fs)
  end

  defn amplitudes(t) do
    Nx.abs(t)
  end
end
```

Lets sample at 256 Hz. We obtain `fs` samples per second in the list  below

> Note they are all real values

```elixir
fs = 2**10
samples = Signal.sample(fs: fs)
```

We transform this time-serie of equally spaced values by `Nx.fft` and obtain a list of Fourrier coeficients: they are complex values indexed by the frequency.

```elixir
dft = Nx.fft(samples)
```

The DFT __approximates the original signal__. It gives us the following information:

> The Fourrier coefficient as the position $i$ of this list gives recovered information of the amplitude (the norm of this coefficient) and the phase of the sampled signal at the frequency $i$ corresponding to the index.

Our frequency resolution  - the accuracy - is limited by the Nyquist frequency, which is half the sampling rate, `fs/2`Hz.

We will therefor limit our study points to the indeices below this threshold value by slicing the tensor.

```elixir
f_max = div(fs, 2)
amplitudes =  Signal.amplitudes(dft) |> Nx.slice([0], [f_max])


f_draw = 100


data1 = %{
  x: 0..f_draw,
  y: Nx.to_list(amplitudes) |> Enum.take(f_draw)
}
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6bnVsbCwiaGVpZ2h0IjozMDAsImxheWVycyI6W3siYWN0aXZlIjp0cnVlLCJjaGFydF90eXBlIjoicG9pbnQiLCJjb2xvcl9maWVsZCI6bnVsbCwiY29sb3JfZmllbGRfYWdncmVnYXRlIjpudWxsLCJjb2xvcl9maWVsZF9iaW4iOm51bGwsImNvbG9yX2ZpZWxkX3NjYWxlX3NjaGVtZSI6bnVsbCwiY29sb3JfZmllbGRfdHlwZSI6bnVsbCwiZGF0YV92YXJpYWJsZSI6ImRhdGExIiwiZ2VvZGF0YV9jb2xvciI6ImJsdWUiLCJsYXRpdHVkZV9maWVsZCI6bnVsbCwibG9uZ2l0dWRlX2ZpZWxkIjpudWxsLCJ4X2ZpZWxkIjoieCIsInhfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ4X2ZpZWxkX2JpbiI6bnVsbCwieF9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ4X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUiLCJ5X2ZpZWxkIjoieSIsInlfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ5X2ZpZWxkX2JpbiI6bnVsbCwieV9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ5X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUifV0sInZsX2FsaWFzIjoiRWxpeGlyLlZlZ2FMaXRlIiwid2lkdGgiOjYwMH0","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 600, height: 300)
|> VegaLite.data_from_values(data1, only: ["x", "y"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "x", type: :quantitative)
|> VegaLite.encode_field(:y, "y", type: :quantitative)
```

We see the peaks at 5Hz, 15Hz and 20Hz with their amplitudes.

This is indeed our incomming signa!! ðŸŽ‰

We can peek into our data:

```elixir
{v, idx} = Nx.top_k(amplitudes, k: 3)
```

# Discrete Fourrier Transform with Nx

```elixir
Mix.install([
  {:nx, "~> 0.9.1"},
  {:kino, "~> 0.14.2"},
  {:kino_vega_lite, "~> 0.1.11"},
  {:exla, "~> 0.9.1"}
], config: [nx: [default_backend: EXLA.Backend]]
)

Nx.Defn.global_default_options(compiler: EXLA, client: :host)
```

## Using complex numbers

Take the complex number $1+i$.

Since `Nx` brings in the library `Complex`, we define a complex number by `Complex.new/1`:

```elixir
one = Complex.new(1,1)
```

Its norm is $ \sqrt{2}$, and angle is $\pi/4$.

Its polar form is:

$ \sqrt{2}\big(\cos(\pi/4) + i\sin(\pi/4)\big) = \sqrt{2} \exp^{i \pi/4}$.

We can use `Complex.from_polar/2`:

```elixir
sqrt_2 = :math.sqrt(2)
a = :math.pi()/4

cx_one = Complex.from_polar(sqrt_2, a)
```

We can also use `Nx` to build a complex:

```elixir
t_one = Nx.complex(Nx.tensor(1), Nx.tensor(1))
```

and compute its norm:

```elixir
Nx.abs(t_one)
```

We also have:

```elixir
i = Nx.Constants.i()

Nx.add(1 , i)
```

## Discrete Fourrier Transform

Suppose we have a periodic signal that we sample in order to understand it.

We will run a Fast Fourrier Taansform. It transforms a time-domain function into the frequency domain.

<https://en.wikipedia.org/wiki/Discrete_Fourier_transform>

<!-- livebook:{"break_markdown":true} -->

Lets build a signal that we want to discover!

It will be the sum of two sinusoid signals, one at 5Hz and the second at 15Hz with amplitudes (1, 0.5).

$\sin(2\pi*5*t / f_s) + \frac12 \sin(2\pi*15*t/f_s)$

Suppose our sampling rate is 64 Hz (meaning 64 samples per second). We build a linear space of 64 equally spaced points with `Nx.linspace`. For each value of the discrete time $t$, we will calculate the "hidden" signal at $t$ in our "Signal" module. This will give us the sampling.

```elixir
defmodule Signal do
  import Nx.Defn

  defn pi(), do: Nx.Constants.pi()


  defn sample(opts) do
    fs = opts[:fs]
    sampling = Nx.linspace(0, fs, n: fs, endpoint: false, type: {:u, 64})
    f1 = 5
    f2 = 15
    Nx.sin(2 * pi() * f1 * sampling / fs) + 1/2 * Nx.sin(2 * pi() * f2 * sampling / fs)
  end

  defn amplitudes(t) do
    Nx.abs(t)
  end
end
```

We obtain 64 samples per second in the list  below

> Note they are all real values

```elixir
fs = 2**6
samples = Signal.sample(fs: fs)
```

We transform this time-serie of equally spaced values by `Nx.fft` and obtain a list of Fourrier coeficients: they are complex values indexed by the frequency.

```elixir
dft = Nx.fft(samples)
```

This gives us the following information:

> The Fourrier coefficient as the position $i$ of this list gives the information of the amplitude (the norm of this coefficient) of the sampled signal at the frequency $i$.

Our frequency resolution  - the accuracy - is limited by the Nyquist frequency, which is half the sampling rate, thus up to 30Hz.

We will therefor limit the display to 32Hz, which are the 32 first points returned by the FFT.

```elixir
f_max = div(fs, 2)

amplitudes =  Signal.amplitudes(dft)

data1 = %{
  x: 0..f_max,
  y: Nx.to_list(amplitudes) |> Enum.take(f_max)
}
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6bnVsbCwiaGVpZ2h0IjozMDAsImxheWVycyI6W3siYWN0aXZlIjp0cnVlLCJjaGFydF90eXBlIjoicG9pbnQiLCJjb2xvcl9maWVsZCI6bnVsbCwiY29sb3JfZmllbGRfYWdncmVnYXRlIjpudWxsLCJjb2xvcl9maWVsZF9iaW4iOm51bGwsImNvbG9yX2ZpZWxkX3NjYWxlX3NjaGVtZSI6bnVsbCwiY29sb3JfZmllbGRfdHlwZSI6bnVsbCwiZGF0YV92YXJpYWJsZSI6ImRhdGExIiwiZ2VvZGF0YV9jb2xvciI6ImJsdWUiLCJsYXRpdHVkZV9maWVsZCI6bnVsbCwibG9uZ2l0dWRlX2ZpZWxkIjpudWxsLCJ4X2ZpZWxkIjoieCIsInhfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ4X2ZpZWxkX2JpbiI6bnVsbCwieF9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ4X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUiLCJ5X2ZpZWxkIjoieSIsInlfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ5X2ZpZWxkX2JpbiI6bnVsbCwieV9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ5X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUifV0sInZsX2FsaWFzIjoiRWxpeGlyLlZlZ2FMaXRlIiwid2lkdGgiOjYwMH0","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 600, height: 300)
|> VegaLite.data_from_values(data1, only: ["x", "y"])
|> VegaLite.mark(:point)
|> VegaLite.encode_field(:x, "x", type: :quantitative)
|> VegaLite.encode_field(:y, "y", type: :quantitative)
```

We see a peak at 5Hz and one at 15Hz with amplitude about 2 times less. This is indeed our incomming signa!! ðŸŽ‰
